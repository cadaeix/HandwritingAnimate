# This is the base script without the CLI tool, parameters are in the main()
# Pretty much generated by Claude.ai with a bit of tweaking

import xml.etree.ElementTree as ET
from svgpathtools import parse_path
from PIL import Image, ImageDraw
import numpy as np


def extract_paths_data(svg_file):
    tree = ET.parse(svg_file)
    root = tree.getroot()
    paths = root.findall(".//{http://www.w3.org/2000/svg}path")

    width = height = None
    if "width" in root.attrib and "height" in root.attrib:
        width = int(float(root.attrib["width"]))
        height = int(float(root.attrib["height"]))
    else:
        viewbox = root.attrib.get("viewBox")
        if viewbox:
            _, _, width, height = map(float, viewbox.split())
            width, height = int(width), int(height)

    return [path.get("d") for path in paths], width, height


def parse_svg_paths(path_data_list):
    return [parse_path(d) for d in path_data_list]


def hex_to_rgb(hex_color):
    hex_color = hex_color.lstrip("#")
    return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))


def get_variable_width(t, base_width, max_width):
    # Define the length of the tapering effect (e.g., first and last 15% of the stroke)
    taper_length = 0.05

    if t < taper_length:
        # Start thin and increase to max_width
        return base_width + (max_width - base_width) * (t / taper_length)
    elif t > (1 - taper_length):
        # Start at max_width and decrease to base_width
        return base_width + (max_width - base_width) * ((1 - t) / taper_length)
    else:
        # Middle section maintains max_width
        return max_width


def create_frame(
    paths,
    progress,
    width,
    height,
    color,
    base_stroke_width,
    use_variable_width,
    padding,
):
    img = Image.new("RGBA", (width, height), color=(255, 255, 255, 0))
    draw = ImageDraw.Draw(img)

    xmin = min(path.bbox()[0] for path in paths)
    xmax = max(path.bbox()[1] for path in paths)
    ymin = min(path.bbox()[2] for path in paths)
    ymax = max(path.bbox()[3] for path in paths)

    content_width = xmax - xmin
    content_height = ymax - ymin

    scale_x = (width - 2 * padding) / content_width
    scale_y = (height - 2 * padding) / content_height
    scale = min(scale_x, scale_y)

    offset_x = (
        padding + (width - 2 * padding - content_width * scale) / 2 - xmin * scale
    )
    offset_y = (
        padding + (height - 2 * padding - content_height * scale) / 2 - ymin * scale
    )

    total_length = sum(path.length() for path in paths)
    current_length = 0

    for path in paths:
        path_length = path.length()
        path_start_progress = current_length / total_length
        path_end_progress = (current_length + path_length) / total_length

        if progress <= path_start_progress:
            continue
        elif progress >= path_end_progress:
            # Draw the entire path
            draw_path(
                draw,
                path,
                scale,
                offset_x,
                offset_y,
                color,
                base_stroke_width,
                use_variable_width,
                0,
                1,
            )
        else:
            # Draw partial path
            path_progress = (progress - path_start_progress) / (
                path_end_progress - path_start_progress
            )
            draw_path(
                draw,
                path,
                scale,
                offset_x,
                offset_y,
                color,
                base_stroke_width,
                use_variable_width,
                0,
                path_progress,
            )
            break

        current_length += path_length

    return img


def draw_path(
    draw,
    path,
    scale,
    offset_x,
    offset_y,
    color,
    base_stroke_width,
    use_variable_width,
    start,
    end,
):
    cumulative_length = np.cumsum([seg.length() for seg in path])
    total_path_length = cumulative_length[-1]

    points = []
    widths = []

    for i, segment in enumerate(path):
        seg_start = cumulative_length[i - 1] / total_path_length if i > 0 else 0
        seg_end = cumulative_length[i] / total_path_length

        if end <= seg_start:
            break
        if start >= seg_end:
            continue

        t_start = max(0, (start - seg_start) / (seg_end - seg_start))
        t_end = min(1, (end - seg_start) / (seg_end - seg_start))

        # Increase the number of points sampled along each segment
        num_points = max(50, int(500 * segment.length() / total_path_length))
        seg_points = [segment.point(t) for t in np.linspace(t_start, t_end, num_points)]
        points.extend(seg_points)

        if use_variable_width:
            # Calculate the global t value for each point in this segment
            global_t_values = np.linspace(
                seg_start + t_start * (seg_end - seg_start),
                seg_start + t_end * (seg_end - seg_start),
                num_points,
            )
            seg_widths = [
                get_variable_width(t, base_stroke_width, base_stroke_width * 2)
                for t in global_t_values
            ]
            widths.extend(seg_widths)
        else:
            widths.extend([base_stroke_width] * num_points)

    # Use a smoother drawing method
    for i in range(len(points) - 1):
        p1 = points[i]
        p2 = points[i + 1]
        w = (widths[i] + widths[i + 1]) / 2  # Average width between two points
        draw.line(
            [
                (p1.real * scale + offset_x, p1.imag * scale + offset_y),
                (p2.real * scale + offset_x, p2.imag * scale + offset_y),
            ],
            fill=color,
            width=int(w),
            joint="curve",  # This can help smooth out corners
        )


def create_animation(
    paths,
    width,
    height,
    duration,
    fps,
    color,
    base_stroke_width,
    use_variable_width,
    linger_time,
    padding,
):
    total_frames = int((duration + linger_time) * fps)
    animation_frames = int(duration * fps)
    linger_frames = total_frames - animation_frames

    frames = []

    for i in range(animation_frames):
        progress = (i + 1) / animation_frames
        frame = create_frame(
            paths,
            progress,
            width,
            height,
            color,
            base_stroke_width,
            use_variable_width,
            padding,
        )
        frames.append(frame)

    # Add lingering frames
    last_frame = frames[-1]
    frames.extend([last_frame] * linger_frames)

    return frames


def main():
    svg_file = "input.svg"
    output_file = "output.gif"
    duration = 4  # Animation duration in seconds
    fps = 30  # Frames per second
    color_hex = (
        "#000000"  # Default color is black, can be changed to any hex color code
    )
    base_stroke_width = 2  # Base stroke width
    use_variable_width = True  # Set to False for constant width
    linger_time = 1  # Time in seconds to linger on the completed text
    padding_percent = 0.05  # Padding as a percentage of the image size

    paths_data, width, height = extract_paths_data(svg_file)
    paths = parse_svg_paths(paths_data)

    if width is None or height is None:
        print("Could not extract dimensions from SVG. Using default values.")
        width, height = 800, 600
    else:
        print(f"Extracted dimensions from SVG: {width}x{height}")

    padding = int(min(width, height) * padding_percent)
    width += 2 * padding
    height += 2 * padding

    color_rgb = hex_to_rgb(color_hex)
    color = color_rgb + (255,)  # Add alpha channel for full opacity
    frames = create_animation(
        paths,
        width,
        height,
        duration,
        fps,
        color,
        base_stroke_width,
        use_variable_width,
        linger_time,
        padding,
    )

    # Save as GIF with transparency
    frames[0].save(
        output_file,
        save_all=True,
        append_images=frames[1:],
        optimize=False,
        duration=int(1000 / fps),
        loop=0,
        disposal=2,
        transparency=0,
    )
    print(f"Animation saved as {output_file}")


if __name__ == "__main__":
    main()
